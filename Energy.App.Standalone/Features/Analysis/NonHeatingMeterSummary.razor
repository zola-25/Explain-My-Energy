@inherits FluxorComponent
@inject IDispatcher Dispatcher
@if (_ready)
{
    // Tooltips/badges?
    <MudItem xs="12" sm="6" md="4">
        <HistoricalAnalysisCard PrimaryHeatSource="false"
                            Term="_calendarTerm"
                            MeterType="MeterType"
                            Period="RelativePeriod.Previous"
                            DurationAnalysis="_previousDurationAnalysis">
        </HistoricalAnalysisCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="4">
        <CurrentPeriodAnalysisCard PrimaryHeatSource="false"
                               Term="_calendarTerm"
                               MeterType="MeterType"
                               TotalsForecast="_currentTermForecastAnalysis"
                               TotalsSoFar="_thisDurationAnalysis">
        </CurrentPeriodAnalysisCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="4">
        <ForecastCard PrimaryHeatSource="false"
            Term="_calendarTerm"
                      ForecastAnalysis="_nextTermForecastAnalysis"
                      MeterType="MeterType">
        </ForecastCard>
    </MudItem>

}

@code {

    [Parameter, EditorRequired]
    public MeterType MeterType { get; set; }


    [Inject]
    public IState<AnalysisOptionsState> AnalysisOptionsState { get; set; }


    [Inject]
    ISimpleForecastAnalyzer SimpleForecastAnalyzer { get; set; }

    [Inject]
    IHistoricalDurationAnalyzer HistoricalDataAnalyzer { get; set; }

    CalendarTerm _calendarTerm;

    HistoricalAnalysis _thisDurationAnalysis;
    HistoricalAnalysis _previousDurationAnalysis;

    ForecastAnalysis _currentTermForecastAnalysis;
    ForecastAnalysis _nextTermForecastAnalysis;
    bool _ready;

    protected override async Task OnParametersSetAsync()
    {

        var initialMeterAnalysisOptions = AnalysisOptionsState.Value[MeterType];

        _ready = false;

        await Task.Delay(1);

        _calendarTerm = initialMeterAnalysisOptions.CalendarTerm;
        await Task.Delay(1);

        SetHistoricalAnalyses();


        await Task.Delay(1);



        switch (MeterType)
        {
            case MeterType.Electricity:

                SubscribeToAction<ElectricityAnalysisOptionsSetCalenderTermAction>(
                    action =>
                    {
                        _calenderTerm = action.CalendarTerm;
                        SetHistoricalAnalyses();
                        SetForecastAnalyses();
                    });
                break;
            case MeterType.Gas:

                SubscribeToAction<GasAnalysisOptionsSetCalenderTermAction>(
                    action =>
                    {
                        _calenderTerm = action.CalendarTerm;
                        SetHistoricalAnalyses();
                        SetForecastAnalyses();
                    });
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }
        SubscribeToAction<NotifyHeatingForecastReadyAction>(action =>
            {
                _degreeDifference = action.DegreeDifference;
                SetForecastAnalyses();
            });


        await Task.Delay(1);

        SetForecastAnalyses();

        Ready = true;
    }


    private Task OnTermChanged(CalendarTerm newTerm)
    {
        _calendarTerm = newTerm;
        SetData();
        StateHasChanged();
        return Task.CompletedTask;
    }

    

    private void SetData()
    {
        _thisDurationAnalysis = HistoricalDataAnalyzer.GetCurrentDurationAnalysis(MeterType, _calendarTerm);
        _previousDurationAnalysis = HistoricalDataAnalyzer.GetPreviousDurationAnalysis(MeterType, _calendarTerm);


        _currentTermForecastAnalysis = SimpleForecastAnalyzer.GetCurrentPeriodForecastTotals(MeterType, _calendarTerm);
        _nextTermForecastAnalysis = SimpleForecastAnalyzer.GetNextPeriodForecastTotals(MeterType, _calendarTerm);
    }


    public void Dispose()
    {
        AnalysisOptions[MeterType].NotifyTermChanged -= OnTermChanged;
    }

}