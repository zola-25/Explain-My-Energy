@using Energy.App.Standalone.Features.Analysis.Services.Analysis.Interfaces;
@implements IDisposable
@inherits FluxorComponent
@inject IState<AnalysisOptionsState> AnalysisOptionsState
@inject IDispatcher Dispatcher

@if (_ready)
{

    // Co2?y
    // Tooltips/badges?
    // Button to switch chart to cost/kwh
    <MudItem xs="12" sm="6" md="4">
        <HistoricalAnalysisCard PrimaryHeatSource="true"
                            Term="_calendarTerm"
                            MeterType="MeterType"
                            Period="RelativePeriod.Previous"
                            DurationAnalysis="_previousDurationAnalysis">
        </HistoricalAnalysisCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="4">
        <CurrentPeriodAnalysisCard PrimaryHeatSource="true"
                               Term="_calendarTerm"
                               MeterType="MeterType"
                               TotalsForecast="_currentTermForecastAnalysis"
                               TotalsSoFar="_thisDurationAnalysis">
        </CurrentPeriodAnalysisCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="4">
        <ForecastCard PrimaryHeatSource="true"
            Term="_calendarTerm"
                      ForecastAnalysis="_nextTermForecastAnalysis"
                      MeterType="MeterType">
        </ForecastCard>
    </MudItem>

}

@code {

    [Parameter, EditorRequired]
    public MeterType MeterType { get; set; }

    [Inject]
    ITempForecastAnalyzer TempForecastAnalyzer { get; set; }

    [Inject]
    IHistoricalDurationAnalyzer HistoricalDataAnalyzer { get; set; }

    [Inject]
    AnalysisOptions AnalysisOptions { get; set; }

    [Inject]
    ForecastState ForecastState { get; set; }


    CalendarTerm _calendarTerm => AnalysisOptionsState.Value[MeterType].CalendarTerm;

    
    bool _ready;

    protected override void OnParametersSet()
    {

        ForecastState.NotifyDegreeDifferenceChange += OnDegreeDifferenceChanged;

        SetData();
        _ready = true;
    }



    HistoricalAnalysis _thisDurationAnalysis => HistoricalDataAnalyzer.GetCurrentDurationAnalysis(MeterType, _calendarTerm);
    HistoricalAnalysis _previousDurationAnalysis => HistoricalDataAnalyzer.GetPreviousDurationAnalysis(MeterType, _calendarTerm);

    ForecastAnalysis _currentTermForecastAnalysis => TempForecastAnalyzer.GetCurrentPeriodForecastTotals(MeterType, _calendarTerm);
    ForecastAnalysis _nextTermForecastAnalysis => TempForecastAnalyzer.GetNextPeriodForecastTotals(MeterType, _calendarTerm);



    private Task OnDegreeDifferenceChanged(MeterType meterType, double degreeDifference)
    {
        if (meterType != MeterType)
        {
            return Task.CompletedTask;
        }
        _currentTermForecastAnalysis = TempForecastAnalyzer.GetCurrentPeriodForecastTotals(MeterType, _calendarTerm);
        _nextTermForecastAnalysis = TempForecastAnalyzer.GetNextPeriodForecastTotals(MeterType, _calendarTerm);

        StateHasChanged();
        return Task.CompletedTask;
    }


    public void Dispose()
    {
        AnalysisOptions[MeterType].NotifyTermChanged -= OnTermChanged;
        ForecastState.NotifyDegreeDifferenceChange -= OnDegreeDifferenceChanged;

    }

}