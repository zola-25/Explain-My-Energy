@using Energy.App.Standalone.Features.Analysis.Services.Analysis.Interfaces;
@using Energy.App.Standalone.Features.Analysis.Services.DataLoading.Interfaces;
@using Energy.App.Standalone.Features.Analysis.Services.DataLoading.Models;
@using Energy.App.Standalone.Features.EnergyReadings.Store;
@using System.Collections.Immutable;
@using Energy.App.Standalone.Features.AppInit.Store.OldAppInit
@using Energy.App.Standalone.Features.Setup.Store.ImmutatableStateObjects;
@inherits FluxorComponent
@inject IDispatcher Dispatcher

@if (!Ready)
{
    <MudItem xs="12" sm="6" md="4">
        <MudText Typo="Typo.h5">@Status</MudText>
        <MudProgressCircular Stroke="7" Size="@Size.Large" Value="Progress" Color="Color.Primary">
        </MudProgressCircular>
    </MudItem>
}
else
{
    <MudItem xs="12" sm="6" md="4">
        <HistoricalAnalysisCard PrimaryHeatSource="true"
                                Term="_calenderTerm"
                                MeterType="MeterType"
                                Period="RelativePeriod.Previous"
                                DurationAnalysis="_previousDurationAnalysis">
        </HistoricalAnalysisCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="4">
        <CurrentPeriodAnalysisCard PrimaryHeatSource="true"
                                   Term="_calenderTerm"
                                   MeterType="MeterType"
                                   TotalsForecast="_currentTermForecastAnalysis"
                                   TotalsSoFar="_thisDurationAnalysis">
        </CurrentPeriodAnalysisCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="4">
        <ForecastCard PrimaryHeatSource="true"
                      Term="_calenderTerm"
                      ForecastAnalysis="_nextTermForecastAnalysis"
                      MeterType="MeterType">
        </ForecastCard>
    </MudItem>
}

@code {

    [Parameter, EditorRequired]
    public MeterType MeterType { get; set; }

    [Inject]
    public IState<AnalysisOptionsState> AnalysisOptionsState { get; set; }

    [Inject]
    ITempForecastAnalyzer TempForecastAnalyzer { get; set; }

    [Inject]
    IHistoricalDurationAnalyzer HistoricalDataAnalyzer { get; set; }


    MeterAnalysisOptions InitialMeterAnalysisOptions => AnalysisOptionsState.Value[MeterType];

    CalendarTerm _calenderTerm;
    decimal _degreeDifference;

    public string Status { get; set; }
    public bool Ready { get; set; }
    public double Progress { get; set; }

    HistoricalAnalysis _thisDurationAnalysis;
    HistoricalAnalysis _previousDurationAnalysis;

    ForecastAnalysis _currentTermForecastAnalysis;
    ForecastAnalysis _nextTermForecastAnalysis;

    AnalysisOptionsActionFactory _analysisOptionsActionFactory;

    [Inject]
    AppInit AppInit { get; set; }

    [Inject]
    IState<ElectricityReadingsState> ElectricityReadingsState { get; set; }

    [Inject]
    IState<GasReadingsState> GasReadingsState { get; set; }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        switch (MeterType)
        {
            case MeterType.Electricity:
            {
                if (ElectricityReadingsState.Value.CostedReadings.Count
                    == 0)
                {
                    AppInit.InitializeElectricity();
                }
                break;
            }
            case MeterType.Gas:
            {
                if (GasReadingsState.Value.CostedReadings.Count
                    == 0)
                {
                    AppInit.InitializeGas();
                }
                break;
            }
            default:
                throw new ArgumentOutOfRangeException();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        Ready = false;

        await Task.Delay(1);
        Progress = 30;
        Status = "Analysing Historical";

        _calenderTerm = InitialMeterAnalysisOptions.CalendarTerm;
        _degreeDifference = InitialMeterAnalysisOptions.DegreeDifference;
        await Task.Delay(1);

        SetHistoricalAnalyses();

        Progress = 60;

        Status = "Analysing Forecast";

        await Task.Delay(1);


        Progress = 80;

        switch (MeterType)
        {
            case MeterType.Electricity:
                SubscribeToAction<ElectricityAnalysisOptionsSetDegreeDifferenceAction>(action =>
                {
                    _degreeDifference = action.DegreeDifference;
                    SetForecastAnalyses();
                });
                SubscribeToAction<ElectricityAnalysisOptionsSetCalenderTermAction>(
                    action =>
                    {
                        _calenderTerm = action.CalendarTerm;
                        SetHistoricalAnalyses();
                        SetForecastAnalyses();
                    });
                break;
            case MeterType.Gas:
                SubscribeToAction<GasAnalysisOptionsSetDegreeDifferenceAction>(action =>
                {
                    _degreeDifference = action.DegreeDifference;
                    SetForecastAnalyses();
                });
                SubscribeToAction<GasAnalysisOptionsSetCalenderTermAction>(
                    action =>
                    {
                        _calenderTerm = action.CalendarTerm;
                        SetHistoricalAnalyses();
                        SetForecastAnalyses();
                    });
                break;
            default:
                throw new ArgumentOutOfRangeException();
        }

        await Task.Delay(1);

        SetForecastAnalyses();

        Ready = true;
    }

    void SetHistoricalAnalyses()
    {
        _thisDurationAnalysis = HistoricalDataAnalyzer.GetCurrentDurationAnalysis(MeterType, _calenderTerm);
        _previousDurationAnalysis = HistoricalDataAnalyzer.GetPreviousDurationAnalysis(MeterType, _calenderTerm);
    }

    void SetForecastAnalyses()
    {
        _currentTermForecastAnalysis = TempForecastAnalyzer.GetCurrentPeriodForecastTotals(MeterType, _calenderTerm, _degreeDifference);
        _nextTermForecastAnalysis = TempForecastAnalyzer.GetNextPeriodForecastTotals(MeterType, _calenderTerm, _degreeDifference);
    }

}