@using Energy.App.Standalone.Features.Analysis.Store.HeatingForecast.Actions;
@using Energy.App.Standalone.Features.EnergyReadings.Electricity.Store;
@using Energy.App.Standalone.Features.EnergyReadings.Gas;
@using Energy.App.Standalone.Features.Analysis.Store.HeatingForecast;
@using Energy.App.Standalone.Features.Setup.Store.MeterSetupStore;
@inherits FluxorComponent     
@implements IAsyncDisposable     
@inject IJSRuntime JsRuntime

@if (_ready)
{
    <h1>Hi</h1>
    <div id="profile-chart-meter-@MeterGlobalId" style="width: 100%; height: 500px; max-width: 100%">
    </div>
}

@code {

    [Parameter, EditorRequired]
    public MeterType MeterType { get; set; }

    [Inject]
    IState<AnalysisOptionsState> AnalysisOptions { get; set; }

    [Inject]
    IState<MeterSetupState> MeterSetupState { get; set; }

    [Inject]
    IState<ElectricityReadingsState> ElectricityReadingsState { get; set; }

    [Inject]
    IState<GasReadingsState> GasReadingsState { get; set; }


    [Inject]
    IState<WeatherState> WeatherState { get; set; }

    [Inject]
    IState<HeatingForecastState> HeatingForecastState { get; set; }

    bool _chartRendered;

    private bool _ready;
    private Guid MeterGlobalId => MeterSetupState.Value[MeterType].GlobalId;

    protected override void OnParametersSet()
    {
        switch (MeterType)
        {
            case MeterType.Electricity:
                SubscribeToAction<ElectricityAnalysisOptionsSetHighlightRangeAction>(action => OnHighlightRangeHandler(action.Start, action.End));
                SubscribeToAction<ElectricityAnalysisOptionsRemoveHighlightRangeAction>(_ => OnRemoveHighlightRangeHandler());
                SubscribeToAction<ElectricityAnalysisOptionsShowCostAction>(c => OnToggledCostChangedHandler(c.ShowCost));
                break;
            case MeterType.Gas:
                SubscribeToAction<GasAnalysisOptionsSetHighlightRangeAction>(action => OnHighlightRangeHandler(action.Start, action.End));
                SubscribeToAction<GasAnalysisOptionsRemoveHighlightRangeAction>(_ => OnRemoveHighlightRangeHandler());
                SubscribeToAction<GasAnalysisOptionsShowCostAction>(c => OnToggledCostChangedHandler(c.ShowCost));
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }
        SubscribeToAction<NotifyHeatingForecastReadyAction>(a => OnDegreeDifferenceHandler(a.DegreeDifference));

        _ready = true;
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var costedReadings = MeterType switch
            {
                MeterType.Gas => GasReadingsState.Value.CostedReadings,
                MeterType.Electricity => ElectricityReadingsState.Value.CostedReadings,
                _ => throw new ArgumentOutOfRangeException()
            };

            var latestReading = costedReadings.Last();
            var firstReading = costedReadings.First();

            var chartReadings = costedReadings.Select(Mapping.MapToChartReading).ToList();

            var forecastDailyCosts = HeatingForecastState.Value.ForecastDailyCosts;
            var applicableForecastCosts = forecastDailyCosts.Where(c => c.UtcTime > latestReading.UtcTime);

            var forecastChartReadings = applicableForecastCosts.Select(Mapping.MapToChartReading).ToList();

            
            var firstReadingTicks = firstReading.UtcTime.eToUnixTicksNoOffset();
            var latestReadingTicks = chartReadings.Last().DateTicks;


            var temperatureIconPoints = WeatherState.Value.WeatherReadings
                .Where(c => c.UtcTime.eToUnixTicksNoOffset() >= firstReadingTicks)
                .Select(c => new TemperatureIconPoint()
                {
                    DateTicks = c.UtcTime.eToUnixTicksNoOffset(),
                    TemperatureCelsius = c.TemperatureAverage,
                    TemperatureCelsiusUnmodified = c.TemperatureAverage,
                    Summary = c.Summary ?? string.Empty,

                }).ToList();


            var meterChartProfile = new MeterChartProfile()
                {
                    ShowCost = AnalysisOptions.Value[MeterType].ShowCost,
                    GlobalId = MeterGlobalId,
                    LatestReading = latestReadingTicks,
                    MostRecentWeekStart = latestReadingTicks,
                    ProfileStart = chartReadings.First().DateTicks,
                    OneMonthInTheFuture = latestReading.UtcTime.AddMonths(1).eToUnixTicksNoOffset(),
                    ProfileEnd = temperatureIconPoints.Last().DateTicks,
                    ChartReadings = chartReadings,
                    ChartDailyForecastReadings = forecastChartReadings
                };
            

            await JsRuntime.InvokeVoidAsync("ChartFunctions.setChart", $"profile-chart-meter-{MeterGlobalId}", meterChartProfile, temperatureIconPoints);
            _chartRendered = true;
        }
    }

    private async void OnHighlightRangeHandler(DateTime start, DateTime end)
    {
        if (!_chartRendered)
        {
            return;
        }

        long startTicks = start.eToUnixTicksNoOffset();
        long endTicks = end.eToUnixTicksNoOffset();


        await JsRuntime.InvokeVoidAsync(
            "ChartFunctions.highlightRange", 
            $"profile-chart-meter-{MeterGlobalId}", 
            startTicks, 
            endTicks);
    }

    private async void OnRemoveHighlightRangeHandler()
    {
        if (!_chartRendered)
        {
            return;
        }

        await JsRuntime.InvokeVoidAsync("ChartFunctions.removeHighlight", $"profile-chart-meter-{MeterGlobalId}");
    }

    private async void OnDegreeDifferenceHandler(decimal degreeDifference)
    {
        if (MeterType.Electricity != MeterType)
        {
            return;
        }

        if (!_chartRendered)
        {
            return;
        }

        // var chartReadings = forecastCosts.Where(c => c.LocalTime > latestReading).
        //     Select(Mapping.MapToChartReading).
        //     ToList();
        //
        // await JsRuntime.InvokeVoidAsync("ChartFunctions.setForecastSeries", $"profile-chart-meter-{MeterGlobalId}", chartReadings, degreeDifference);
    }

    private async void OnToggledCostChangedHandler(bool showCost)
    {
        if (!_chartRendered)
        {
            return;
        }
        await JsRuntime.InvokeVoidAsync("ChartFunctions.toggleCostSeries", $"profile-chart-meter-{MeterGlobalId}", showCost);
    }

    public async ValueTask DisposeAsync()
    {
        await JsRuntime.InvokeVoidAsync("ChartFunctions.dispose", $"profile-chart-meter-{MeterGlobalId}");
    }

}