@inherits FluxorComponent
@implements IAsyncDisposable
@inject IJSRuntime JsRuntime

<MudText Typo="Typo.h4" Align="Align.Center" Class="eme-focus">@MeterType Meter Analysis</MudText>

@if (_ready)
{
    <div id="profile-chart-meter-@MeterGlobalId" class="profile-chart-meter">
    </div>
}

@code {

    [Parameter, EditorRequired]
    public MeterType MeterType { get; set; }

    [Inject]
    IState<AnalysisOptionsState> AnalysisOptions { get; set; }

    [Inject]
    IState<MeterSetupState> MeterSetupState { get; set; }

    [Inject]
    IState<ElectricityReadingsState> ElectricityReadingsState { get; set; }

    [Inject]
    IState<GasReadingsState> GasReadingsState { get; set; }


    [Inject]
    IState<WeatherState> WeatherState { get; set; }

    [Inject]
    IState<HistoricalForecastState> HistoricalForecastState { get; set; }

    bool _chartRendered;

    private bool _ready;
    private Guid MeterGlobalId => MeterSetupState.Value[MeterType].GlobalId;

    protected override void OnParametersSet()
    {
        switch (MeterType)
        {
            case MeterType.Electricity:
                SubscribeToAction<ElectricityAnalysisOptionsSetHighlightRangeAction>(action => OnHighlightRangeHandler(action.Start, action.End));
                SubscribeToAction<ElectricityAnalysisOptionsRemoveHighlightRangeAction>(_ => OnRemoveHighlightRangeHandler());
                SubscribeToAction<ElectricityAnalysisOptionsShowCostAction>(c => OnToggledCostChangedHandler(c.ShowCost));
                break;
            case MeterType.Gas:
                SubscribeToAction<GasAnalysisOptionsSetHighlightRangeAction>(action => OnHighlightRangeHandler(action.Start, action.End));
                SubscribeToAction<GasAnalysisOptionsRemoveHighlightRangeAction>(_ => OnRemoveHighlightRangeHandler());
                SubscribeToAction<GasAnalysisOptionsShowCostAction>(c => OnToggledCostChangedHandler(c.ShowCost));
                break;

            default:
                throw new ArgumentOutOfRangeException();
        }

        _ready = true;
    }

    DateTime _latestReadingTime;

    private List<ChartDailyForecastReading> GetChartDailyForecastReadings(DateTime latestReadingTime)
    {
        var forecastDailyCosts = HistoricalForecastState.Value[MeterType];

        // get the start of the week for the latest reading
        var latestReadingWeekStart = latestReadingTime.eStartOfWeek(DayOfWeek.Monday);

        var lastDate = forecastDailyCosts.Last().UtcTime.eStartOfWeek(DayOfWeek.Monday).AddDays(-1);
        var applicableForecastCosts = forecastDailyCosts.Where(c => c.UtcTime >= latestReadingWeekStart && c.UtcTime <= lastDate);

        var forecastChartReadings = applicableForecastCosts.Select(Mapping.MapToChartReading).ToList();
        return forecastChartReadings;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var costedReadings = MeterType switch
            {
                MeterType.Gas => GasReadingsState.Value.CostedReadings,
                MeterType.Electricity => ElectricityReadingsState.Value.CostedReadings,
                _ => throw new ArgumentOutOfRangeException()
            };

            var latestReading = costedReadings.Last();
            var firstReading = costedReadings.First();

            var chartReadings = costedReadings.Select(Mapping.MapToChartReading).ToList();

            var forecastChartReadings = GetChartDailyForecastReadings(latestReading.UtcTime);

            var firstReadingTicks = firstReading.UtcTime.eToUnixTicksNoOffset();
            var latestReadingTicks = chartReadings.Last().DateTicks;


            var highlightSet = AnalysisOptions.Value[MeterType].HighlightSet;
            var meterChartProfile = new MeterChartProfile()
                {
                    ShowCost = AnalysisOptions.Value[MeterType].ShowCost,
                    GlobalId = MeterGlobalId,
                    LatestReading = latestReadingTicks,
                    MostRecentWeekStart = latestReadingTicks,
                    ProfileStart = chartReadings.First().DateTicks,
                    OneMonthInTheFuture = latestReading.UtcTime.AddMonths(1).eToUnixTicksNoOffset(),
                    ProfileEnd = forecastChartReadings.Last().DateTicks,
                    ChartReadings = chartReadings,
                    ChartDailyForecastReadings = forecastChartReadings,
                    HighlightStart = highlightSet ? AnalysisOptions.Value[MeterType].HighlightStart?.eToUnixTicksNoOffset() : null,
                    HighlightEnd = highlightSet ? AnalysisOptions.Value[MeterType].HighlightEnd?.eToUnixTicksNoOffset() : null
                };

            _latestReadingTime = latestReading.UtcTime;


            await JsRuntime.InvokeVoidAsync("ChartFunctions.setEnergyOnlyChart", $"profile-chart-meter-{MeterGlobalId}", meterChartProfile);


            _chartRendered = true;
        }
    }

    private async void OnHighlightRangeHandler(DateTime start, DateTime end)
    {
        if (!_chartRendered)
        {
            return;
        }

        long startTicks = start.eToUnixTicksNoOffset();
        long endTicks = end.eToUnixTicksNoOffset();


        await JsRuntime.InvokeVoidAsync(
            "ChartFunctions.highlightRange",
            $"profile-chart-meter-{MeterGlobalId}",
            startTicks,
            endTicks);
    }

    private async void OnRemoveHighlightRangeHandler()
    {
        if (!_chartRendered)
        {
            return;
        }

        await JsRuntime.InvokeVoidAsync("ChartFunctions.removeHighlight", $"profile-chart-meter-{MeterGlobalId}");
    }


    private async void OnToggledCostChangedHandler(bool showCost)
    {
        if (!_chartRendered)
        {
            return;
        }
        await JsRuntime.InvokeVoidAsync("ChartFunctions.toggleCostSeries", $"profile-chart-meter-{MeterGlobalId}", showCost);
    }

    public async ValueTask DisposeAsync()
    {
        base.Dispose();
        await JsRuntime.InvokeVoidAsync("ChartFunctions.dispose", $"profile-chart-meter-{MeterGlobalId}");
        _ready = false;
    }

}